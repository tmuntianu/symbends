import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def is_saw(x, y, n,tolerance=0):
    """
    Checks if walk of length n is self-avoiding

    Args:
        (x,y) (list, list): walk of length n
        n (int): length of the walk
    Returns:
        True if the walk is self-avoiding
    """
    return n+1-tolerance <= len(set(zip(x,y))) <= n+1+tolerance #creating a set removes duplicates, so it suffices to check the size of the set

def myopic_saw(n):
    """
    Tries to generate a SAW of length n using the myopic algorithm

    Args:
        n (int): the length of the walk
    Returns:
        (x, y, stuck, steps) (list, list, bool, int):
            (x,y) is a SAW of length <= n
            stuck is 1 if the walk could not terminate
            steps is the number of sites of the final walk
    """
    x, y = [0], [0]
    positions = set([(0,0)])  #positions is a set that stores all sites visited by the walk
    stuck = 0
    for i in range(n):
        deltas = [(1,0), (0,1), (-1,0), (0,-1)]
        deltas_feasible = []  #deltas_feasible stores the available directions
        for dx, dy in deltas:
            if (x[-1] + dx, y[-1] + dy) not in positions:  #checks if direction leads to a site not visited before
                deltas_feasible.append((dx,dy))
        if deltas_feasible:  #checks if there is a direction available
            dx, dy = deltas_feasible[np.random.randint(0,len(deltas_feasible))]  #choose a direction at random among available ones
            positions.add((x[-1] + dx, y[-1] + dy))
            x.append(x[-1] + dx)
            y.append(y[-1] + dy)
        else:  #in that case the walk is stuck
            stuck = 1
            steps = i+1
            break  #terminate the walk prematurely
        steps = n+1
    return x, y, stuck, steps


def dimer(n, tolerance=0):
    """
    Generates a SAW of length n by dimerization

    Args:
        n (int): the length of the walk
    Returns:
        (x, y) (list, list): SAW of length n
    """
    if n <= 3:
        x, y, _, _ = myopic_saw(n) #base case uses the myopic algorithm
        return x, y
    else:
        not_saw = 1
        while not_saw:
            (x_1, y_1) = dimer(n//2)  #recursive call
            (x_2, y_2) = dimer(n-n//2)  #recursive call
            x_2 = [x + x_1[-1] for x in x_2]  #translates the second walk to the end of the first one
            y_2 = [y + y_1[-1] for y in y_2]  #translates the second walk to the end of the first one
            x_concat, y_concat = x_1 + x_2[1:], y_1 + y_2[1:]  #performs concatenation
            if is_saw(x_concat, y_concat, n, tolerance):   #if walk obtained is SAW, stop
                not_saw = 0
        return x_concat, y_concat

def plot_dimer(n, tolerance=0):
    """
    Plots the output of the dimerization method

    Args:
        n (int): the length of the walk
    Returns:
        Plot of the output of the dimerization algorithm
    """
    x, y = dimer(n, tolerance)
    plt.figure(figsize = (8, 8))
    plt.plot(x, y, 'b.-', linewidth = 1)
    plt.plot(0, 0, 'go', ms = 12, label = 'Start')
    plt.plot(x[-1], y[-1], 'ro', ms = 12, label = 'End')
    plt.axis('equal')
    plt.legend()
    plt.title('Figure 5: SAW of length ' + str(n)+ ' generated by dimerization',
              fontsize=14, fontweight='bold', y = 1.05)
    plt.show()


#definition of elements of the dihedral group
m1, m2, m3, m4 = np.array([[1,0],[0,1]]), np.array([[0,-1],[1,0]]), np.array([[-1,0],[0,-1]]), np.array([[0,1],[-1,0]])
m5, m6, m7, m8 = np.array([[1,0],[0,-1]]), np.array([[0,1],[1,0]]), np.array([[-1,0],[0,1]]), np.array([[0,-1],[-1,0]])
m_list = [m1, m2, m3, m4, m5, m6, m7, m8]

def pivot(n, samples, method, tolerance=0):
    """
    Generates SAWs of length n using the pivot algorithm
    For this algorithm, SAWs are represented by a 2*(n+1) matrix.
    This makes it very simple to pivot walks (via matrix multiplication)

    Args:
        n (int): length of the SAWs
        samples (int): length of the Markov chain to be generated
        method (string): either dimerization or a straight rod
    Returns:
        results (list): list of the resulting SAWs
    """
    results = []
    #initialization
    if method == 'dimer':
        x, y = dimer(n)
    else:
        x, y = range(0,n+1), [0 for _ in range(n+1)]  #straight horizontal rod
    walk = np.c_[x,y].T
    results.append(walk)
    #main step
    for _ in range(samples):
        i = np.random.randint(0,n)  #choose the location of the pivot uniformly at random
        m = m_list[np.random.randint(0,8)]  #choose transformation in the dihedral group uniformly at random
        walk_1, walk_2 = walk[:, 0:i+1], walk[:, i+1:]  #split walk in 2 parts
        pivot = np.vstack(walk[:, i])  #site that will be used as pivot
        walk_2 = np.dot(m, (walk_2 - pivot)) + pivot   #transform second part of the walk around the pivot
        walk_piv = np.c_[walk_1,walk_2]  #concatenate
        uniq = np.unique(walk_piv, axis=1).shape[1]
        # if np.unique(walk_piv, axis=1).shape[1] == (n+1) or \
        #         (tolerance != 0 and np.unique(walk_piv, axis=1).shape[1] <= (n+1-tolerance)):   #check if resulting walk is SAW
        if uniq == (n+1) or (tolerance != 0 and (n+1-tolerance <= uniq <= n+1+tolerance)):
            results.append(walk_piv)
            walk = walk_piv
        else:
            results.append(walk)
    return results

def plot_pivot(n, samples, method, i, j, tolerance=0):
    """
    Plots SAWs generated by the pivot algorithm

    Args:
        n (int): length of SAWs
        samples (int): length of the Markov chain
        method (string): either dimerization or a straight rod
        i, j (int, int): plot all walks between the i-th and the j-th
    Returns:
        Plot of SAWs generated by the pivot algorithm
    """
    plt.figure(figsize = (10, 8))
    results = pivot(n, samples, method, tolerance)
    for k in range(i,j):
        walk = results[k]
        x, y = walk[0], walk[1]
        plt.plot(x, y, '.-', linewidth = 1)
        plt.plot(x[-1], y[-1], 'ro', ms = 12)
    plt.plot(0, 0, 'ro', ms = 12, label = 'End')
    plt.plot(0, 0, 'go', ms = 12, label = 'Start')
    plt.axis('equal')
    plt.legend()
    if method == 'dimer':
        plt.title(str(j-i) + ' SAWs of length ' + str(n) + ' generated by pivot,\n'+
                  'initialization by dimerization',
              fontsize=14, fontweight='bold', y = 1.05)
    else:
        plt.title(str(j-i) + ' SAWs of length ' + str(n) + ' generated by pivot,\n'+
                  'initialization by a horizontal rod',
              fontsize=14, fontweight='bold', y = 1.05)
    plt.show()
